# coding=utf-8
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# All Pairs Shortest Path

# Please refer to the apsp.sql_in file for the documentation

"""
@file apsp.py_in

@namespace graph
"""


import plpy
from graph_utils import *
from utilities.control import MinWarning
from utilities.utilities import _assert
from utilities.utilities import extract_keyvalue_params
from utilities.utilities import unique_string
from utilities.validate_args import get_cols
from utilities.validate_args import unquote_ident
from utilities.validate_args import table_exists
from utilities.validate_args import columns_exist_in_table
from utilities.validate_args import table_is_empty

m4_changequote(`<!', `!>')

def graph_apsp(schema_madlib, vertex_table, vertex_id, edge_table,
		edge_args, out_table, **kwargs):
	"""
    Single source shortest path function for graphs using the Bellman-Ford
    algorhtm [1].
    Args:
        @param vertex_table     Name of the table that contains the vertex data.
        @param vertex_id        Name of the column containing the vertex ids.
        @param edge_table       Name of the table that contains the edge data.
        @param edge_args        A comma-delimited string containing multiple
        						named arguments of the form "name=value".
        @param out_table   	    Name of the table to store the result of SSSP.

    [1] https://en.wikipedia.org/wiki/Bellman-Ford_algorithm
    """

	with MinWarning("warning"):

		INT_MAX = 2147483647
		INFINITY = "'Infinity'"
		EPSILON = 0.000001

		params_types = {'src': str, 'dest': str, 'weight': str}
		default_args = {'src': 'src', 'dest': 'dest', 'weight': 'weight'}
		edge_params = extract_keyvalue_params(edge_args,
                                            params_types,
                                            default_args)
		if vertex_id is None:
			vertex_id = "id"

		src = edge_params["src"]
		dest = edge_params["dest"]
		weight = edge_params["weight"]

		is_hawq = m4_ifdef(<!__HAWQ__!>, <!True!>, <!False!>)
		is_hawq = True

		out_table_1 = unique_string(desp='out_table_1')
		out_table_2 = unique_string(desp='out_table_2')
		tmp_view = unique_string(desp='tmp_view')
		distribution = m4_ifdef(<!__POSTGRESQL__!>, <!''!>,
			<!"DISTRIBUTED BY ({0})".format(src)!>)
		local_distribution = m4_ifdef(<!__POSTGRESQL__!>, <!''!>,
			<!"DISTRIBUTED BY (id)"!>)

		validate_graph_coding(vertex_table, vertex_id, edge_table,
			edge_params, out_table, "APSP")

		plpy.execute(
			""" CREATE TABLE {out_table} AS
				SELECT v1.{vertex_id} AS {src}, v2.{vertex_id} AS {dest},
					CAST('Infinity' AS DOUBLE PRECISION) AS {weight},
					NULL::INT AS parent
				FROM {vertex_table} v1, {vertex_table} v2
				WHERE v1.{vertex_id} IS NOT NULL AND v2.{vertex_id} IS NOT NULL
				{distribution} """.format(**locals()))

		# GPDB and HAWQ have distributed by clauses to help them with indexing.
		# For Postgres we add the indices manually.
		sql_index = m4_ifdef(<!__POSTGRESQL__!>,
			<!""" CREATE INDEX ON {out_table} ({src});
			""".format(**locals())!>, <!''!>)
		plpy.execute(sql_index)

		# The source can be reached with 0 cost and next is itself.
		plpy.execute(
			""" UPDATE {out_table} SET
			{weight} = 0, parent = {vertex_id}
			FROM {vertex_table}
			WHERE {out_table}.{src} = {vertex_id}
			AND {out_table}.{dest} = {vertex_id}
			""".format(**locals()))

		# Distance = 1: every edge means there is a path from src to dest
		plpy.execute(
			""" UPDATE {out_table} SET
			{weight} = edge.{weight}, parent = edge.{dest}
			FROM {edge_table} AS edge
			WHERE {out_table}.{src} = edge.{src}
			AND {out_table}.{dest} = edge.{dest}
			AND {out_table}.{weight} > edge.{weight}
			""".format(**locals()))
		plpy.info("here1")
		if is_hawq:
			plpy.execute(""" ALTER TABLE {out_table} RENAME TO {out_table_1}
				""".format(**locals()))
			plpy.execute(""" CREATE TABLE {out_table_2} AS
				SELECT * FROM {out_table_1} LIMIT 0""".format(**locals()))
			plpy.info("here2")

		ot_sql = """ SELECT * FROM {out_table}
			WHERE {weight} != 'Infinity' AND {src} != {dest} """
		plpy.info("here3")
		if is_hawq:
			plpy.info("here4")
			while 1:
				ot_sql1 = ot_sql.format(out_table = out_table_1,
					weight = weight, src = src, dest = dest)

				update_sql = """ CREATE VIEW {tmp_view} AS
					SELECT y.{src}, y.{dest}, y.{weight}, y.parent
					FROM  {out_table_1} AS out INNER JOIN
						(SELECT x.{src}, x.{dest}, x.{weight}, out.{dest} as parent
						FROM ({ot_sql1}) AS out INNER JOIN {edge_table} AS edge
							ON (out.{dest} = edge.{src})
						INNER JOIN
						(SELECT out.{src}, edge.{dest},
							min(out.{weight}+edge.{weight}) AS {weight}
						FROM ({ot_sql1}) AS out, {edge_table} AS edge
						WHERE out.{dest} = edge.{src}
						GROUP BY out.{src},edge.{dest}) x ON
							(x.{src} = out.{src} AND x.{dest} = edge.{dest})
						WHERE ABS(out.{weight}+edge.{weight} - x.{weight})
							< {EPSILON}) y ON
							(y.{src} = out.{src} AND y.{dest} = out.{dest})
					WHERE y.{weight} < out.{weight}
				""".format(**locals())

				plpy.execute(update_sql)
				plpy.info("here5")
				if table_is_empty(tmp_view):
					plpy.execute("DROP VIEW {0}".format(tmp_view))
					plpy.execute("ALTER TABLE {0} RENAME TO {1}".format(
						out_table_1,out_table))
					break

				fill_sql = """ INSERT INTO {out_table_2}
					SELECT * FROM {out_table_1} AS out WHERE NOT EXISTS
						(SELECT 1 FROM {tmp_view} AS t
						WHERE t.{src} = out.{src} AND
							t.{dest} = out.{dest})
					UNION
					SELECT * FROM {tmp_view}""".format(**locals())
				plpy.execute(fill_sql)
				plpy.info("here6")
				plpy.execute("DROP VIEW {0}".format(tmp_view))
				plpy.execute("TRUNCATE TABLE {0}".format(out_table_1))
				tmpname = out_table_1
				out_table_1 = out_table_2
				out_table_2 = tmpname

		else:
			ot_sql = ot_sql.format(**locals())
			while 1:
				updates = plpy.execute(
					"""	UPDATE {out_table}
						SET {weight} = message.{weight},
							parent = message.parent FROM
						(	SELECT x.{src}, x.{dest}, x.{weight}, out.{dest} as parent
							FROM ({ot_sql}) AS out INNER JOIN {edge_table} AS edge
								ON (out.{dest} = edge.{src})
							INNER JOIN
							(SELECT out.{src}, edge.{dest},
								min(out.{weight}+edge.{weight}) AS {weight}
							FROM ({ot_sql}) AS out, {edge_table} AS edge
							WHERE out.{dest} = edge.{src}
							GROUP BY out.{src},edge.{dest}) x ON
								(x.{src} = out.{src} AND x.{dest} = edge.{dest})
							WHERE ABS(out.{weight}+edge.{weight} - x.{weight})
								< {EPSILON}
						) message
						WHERE message.{src} = {out_table}.{src} AND
							message.{dest} = {out_table}.{dest} AND
							message.{weight} < {out_table}.{weight}
					""".format(**locals()))
				if updates.nrows() == 0:
					break
	plpy.info("here7")
	return None

def graph_apsp_get_path(schema_madlib, apsp_table,
	source_vertex, dest_vertex, **kwargs):
	"""
	Helper function that can be used to get the shortest path between any 2
	vertices
    Args:
    	@param apsp_table		Name of the table that contains the APSP
    							output.
        @param source_vertex	The vertex that will be the source of the
            					desired path.
        @param dest_vertex		The vertex that will be the destination of the
            					desired path.
	"""

	cur_dest = dest_vertex

	rows = get_cols(apsp_table)
	src_row = rows[0]
	dest_row = rows[1]

	ret = [dest_vertex]
	if source_vertex == dest_vertex:
		return ret
	plan_name = unique_string(desp='plan')

	plpy.execute(""" PREPARE {plan_name} (int,int) AS
		SELECT parent FROM {apsp_table} WHERE {src_row} = $1 AND {dest_row} = $2
		LIMIT 1 """.format(**locals()))
	sql = "EXECUTE {plan_name} ({source_vertex},{cur_dest})"
	parent = plpy.execute(sql.format(**locals()))

	if parent.nrows() == 0:
		plpy.error("""Graph APSP: Vertex {source_vertex} or {dest_vertex} do not exist
			in the APSP table {apsp_table}""".format(**locals()))

	parent = parent[0]['parent']
	if parent is None:
		plpy.error("""Graph APSP: There isn't a path from vertex {source_vertex} to vertex {dest_vertex} """.format(**locals()))

	while parent != cur_dest:
		ret.append(parent)
		cur_dest = parent
		parent = plpy.execute(sql.format(**locals()))[0]['parent']

	ret.append(source_vertex)
	ret = ret[::-1]
	return ret
